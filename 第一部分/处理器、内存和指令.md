# 处理器、内存和指令

处理器是一台电子计算机的核心，它会在振荡器脉冲的记录下，从内存中获取指令，并发起一系列由该指令所定义的操作。

当这些操作结束后，它接着再取下一条指令。这个过程是连续不断、循环往复的。

在处理器的底部或者四周，有大量的引脚，可以接受从外面来的电信号，或者向外发出电信号。

处理器的引脚很多，其中有一部分是用来将参与运算的数字送入处理器内部。有些引脚是复用的，假如现在要进行加法运算，那么我们要重复使用这些引脚，来依次将被加数和加数送入。

一旦被加数通过引脚送入处理器，代表这个二进制数字的一组电信号就会出现在与引脚相连的内部线路上。这是一排高低电平的组合，代表着二进制数的每一位。这时候，必须用一个称为寄存器（Register）的电路锁住。之所以要这样做，是因为相同的引脚和线路马上还要用于输入加数。

也正是因为这个原因，这些内部线路称为处理器内部总线。

寄存器是双向器件，可以在一端接受输入并加以锁存，同时，它也会在另一端产生一模一样的输出。

与寄存器相连的，是算术逻辑单元，或者算术逻辑部件（Arithmetic Logic Unit，ALU），它是专门负责运算的电路。

一旦寄存器锁存了参与运算的两个数，算术逻辑部件就会输出想加的结果，这个结果可以临时用另一个寄存器锁存，稍后再通过处理器数据总线送到处理器外面，或者再次送入前面两个寄存器之一。

处理器内部有一个控制器，在指令的执行过程中，它负责给各个部件发送控制信号，使各个部件在某个正确的时间点上执行某个动作。同时，它还负责决定某个正确的时间点上执行某个动作。同时，它还负责决定在某个时间点上哪个部件有权使用总线，以免彼此发生冲突。

和寄存器不同，内存用于保存更多的比特。对于用的最多的个人计算机来说，内存按字节来组织，单次访问的最小单位是1字节，这是最基本的存储单位。

内存中的每字节都对应着一个地址。

为了访问内存，处理器需要给出一个地址。访问包括读和写，为此，处理器还要指明，本次访问是读访问还是写访问。如果是写访问，则还要给出待写入的数据。

尽管内存的最小组成单位是字节，但是，经过精心的设计和安排，它能够按字节、字、双字和四字进行访问。换句话说，仅通过单次访问就能处理8位、16位、32位或者64位的二进制数。

处理器的设计者用某些处理器进行的操作，这称为指令（Instruction），或者叫机器指令，因为只有处理器才认得它们。

一般来说，指令由操作码和操作数构成，但也有小部分指令仅有操作码，而不含操作数。

对于Intel处理器来说，如果访问内存中的一个字，那么，它规定高字节位于高地址部分，低字节位于低地址部分，这称为低端字节序（Little Endian）。至于其他公司的处理器，则可能情况正好相反，称为高端字节序。

因为处理器是自动按顺序取指令并加以执行的，在指令中混杂了非指令的数据会导致处理器不能正常工作。为此，指令和数据要分开存放，分别位于内存中的不同区域，存放指令的区域叫代码区，存放数据的区域叫数据区。为了让处理器正确识别和执行指令，工程技术人员必须精心安排，并告诉处理器要执行的指令位于内存中的什么位置。

一个处理器能够识别的指令的集合，称为该处理器的指令集。

8086处理器内部有8个16位的通用寄存器，分别被命名为AX、BX、CX、DX、SI、DI、BP、SP。“通用”的意思是，它们之中的大部分都可以根据需要用于多种目的。

这8个寄存器中的前4个，即AX、BX、CX和DX，又各自可以拆分成两个8位的寄存器来使用，总共可以提供8个8位的寄存器AH、AL、BH、CH、CL、DH和DL。这样一来，当需要在寄存器和寄存器之间，或者寄存器和内存单元之间进行8位的数据传送或者算术逻辑运算时，使用它们就很方便。

处理器是自动化的器件，在给出了起始地址之后，它将从这个地址开始，自动地取出每条指令并加以执行。只要每条指令都正确无误，它就能准确地知道下一条指令的地址。这就意味着，完成某个工作的所有指令，必须集中在一起，处于内存的某个位置，形成一个段，叫做代码段。事情是明摆着的，要是指令并没有一条挨着一条存放，中间夹杂了其他非指令的数据，处理器将因为不能识别而出错。

为了做某件事而编写的指令，它们一起形成了我们平时所说的程序。程序总要操作大量的数据，这些数据也应该集中在一起，位于内存中的某个地方，形成一个段，叫做数据段。

严格地说，数据段和代码段是不需要连续的，但这里把它们挨在一起更自然一些。

这里确实有一个难题。

在前面的例子中，所有在执行时需要访问内存单元的指令，使用的都是真实的内存地址。

在大多数情况下，你所运行的程序，在内存中被加载的位置完全是随机的，哪里有空闲的地方，它就被加载到哪里，并从那里开始被处理器执行。但是，同样是那个程序，一旦它在内存中的位置发生了改变，灾难就出现了。

我们在指令中使用了绝对内存地址（物理地址），这样的程序是无法重定位的。为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址，而不能使用真实的物理地址。当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算。

在任何时候，程序的重定位都是非常棘手的事情。当然，也有好几种解决的办法。在8086处理器上，这个问题特别容易解决，因为该处理器在访问内存时使用了分段机制，我们可以借助该机制。

根据需要，段可以开始于内存中的任何位置。

在分段之后，它们的地址可以只相对于自己所在的段。这样，它们相对于段开始的距离分别为0、1、2、3、4、5，这叫做偏移地址。

于是，当采用分段策略之后，一个内存单元的地址实际上就可以用“段：偏移”或者“段地址：偏移地址”来表示，这就是通常所说的逻辑地址。

为了在硬件一级提供对“段地址：偏移地址”内存访问模型的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器（Code Segment，CS）和数据段寄存器（Data Segement，DS）。

对CS内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好DS寄存器，使之指向数据段。

除此之外，最重要的是，当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址，而不是物理地址。这样，一旦处理器遇到一条访问内存的指令，它将把DS中的数据段其实地址和指令中提供的段内偏移想加，来得到访问内存所需要的物理地址。

处理器能够自动运行，这时控制器的功劳。为了加快指令执行速度，8086内部有一个6字节的指令预取队列，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达6个字节的指令流可以排队等待解码和执行。

8086内部有4个段寄存器。其中，CS是代码寄存器，DS是数据寄存器，ES是附加段（Extra Segment）寄存器。附加段的意思是，他是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS指向一个，ES指向另一个。可以在指令中指定使用DS和ES中的哪一个，如果没有指定，则默认是使用DS。SS是栈段寄存器，以后会讲到，而且非常重要。

IP是指令指针（Instruction Pointer）寄存器，它只和CS一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS指向代码段的起始地址，IP则指向段内偏移。这样，由CS和IP共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP的值，使它指向下一条指令。

当然，如果在指令的执行过程中需要访问内存单元，那么，处理器将用DS的值和指令中提供的偏移地址想加，来形成访问内存所需的物理地址。

麻烦的是，8086却提供了20根地址线。换句话说，它提供的是20位的物理地址。

因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，段地址分别是0000H、0001H、0002H、0003H，……，一直到FFFFH。在这种情况下，每个段正好16个字节，偏移地址从0000H到000FH。

同样在不允许段之间重叠的情况下，每个段的最大长度是64KB，因为偏移地址也是16位的，从0000H到FFFFH。在这种情况下，1MB的内存，最多只能划分16个段，每段长64KB，段地址分别是0000H、1000H、2000H、3000H，……，一直到F000H。

以上所说的只是两种最典型的情况。通常情况下，段地址的选择取决于内存中哪些区域是空闲的。

正是由于段的划分非常自由，使得8086的内存访问也非常随意。同一个物理地址，或者同一片内存区域，根据需要，可以随意指定一个段来访问它，前提是那个物理地址位于高端的64KB范围内。也就是说，同一个物理地址，实际上对应着多个逻辑地址。

